import { distinctUntilChanged } from 'rxjs/operators';
import { NgRedux } from '../components/ng-redux';
/**
 * OPTIONS_KEY: this is per-class (static) and holds the config from the
 * @SubStore decorator.
 */
const OPTIONS_KEY = '@angular-redux::substore::class::options';
/**
 * INSTANCE_SUBSTORE_KEY, INSTANCE_SELECTIONS_KEY: these are per-instance
 * (non-static) and holds references to the substores/selected observables
 * to be used by an instance of a decorated class. I'm not using
 * reflect-metadata here because I want
 *
 * 1. different instances to have different substores in the case where
 * `basePathMethodName` is dynamic.
 * 2. the instance substore to be garbage collected when the instance is no
 * longer reachable.
 * This is therefore an own-property on the actual instance of the decorated
 * class.
 */
const INSTANCE_SUBSTORE_KEY = '@angular-redux::substore::instance::store';
const INSTANCE_SELECTIONS_KEY = '@angular-redux::substore::instance::selections';
/**
 * Used to detect when the base path changes - this allows components to
 * dynamically adjust their selections if necessary.
 */
const INSTANCE_BASE_PATH_KEY = '@angular-redux::substore::instance::basepath';
const getClassOptions = (decoratedInstance) => decoratedInstance.constructor[OPTIONS_KEY];
const ɵ0 = getClassOptions;
/** @hidden */
export const setClassOptions = (decoratedClassConstructor, options) => {
    decoratedClassConstructor[OPTIONS_KEY] = options;
};
// I want the store to be saved on the actual instance so
// 1. different instances can have distinct substores if necessary
// 2. the substore/selections will be marked for garbage collection when the
//    instance is destroyed.
const setInstanceStore = (decoratedInstance, store) => (decoratedInstance[INSTANCE_SUBSTORE_KEY] = store);
const ɵ1 = setInstanceStore;
const getInstanceStore = (decoratedInstance) => decoratedInstance[INSTANCE_SUBSTORE_KEY];
const ɵ2 = getInstanceStore;
const getInstanceSelectionMap = (decoratedInstance) => {
    const map = decoratedInstance[INSTANCE_SELECTIONS_KEY] || {};
    decoratedInstance[INSTANCE_SELECTIONS_KEY] = map;
    return map;
};
const ɵ3 = getInstanceSelectionMap;
const hasBasePathChanged = (decoratedInstance, basePath) => decoratedInstance[INSTANCE_BASE_PATH_KEY] !== (basePath || []).toString();
const ɵ4 = hasBasePathChanged;
const setInstanceBasePath = (decoratedInstance, basePath) => {
    decoratedInstance[INSTANCE_BASE_PATH_KEY] = (basePath || []).toString();
};
const ɵ5 = setInstanceBasePath;
const clearInstanceState = (decoratedInstance) => {
    decoratedInstance[INSTANCE_SELECTIONS_KEY] = null;
    decoratedInstance[INSTANCE_SUBSTORE_KEY] = null;
    decoratedInstance[INSTANCE_BASE_PATH_KEY] = null;
};
const ɵ6 = clearInstanceState;
/**
 * Gets the store associated with a decorated instance (e.g. a
 * component or service)
 * @hidden
 */
export const getBaseStore = (decoratedInstance) => {
    // The root store hasn't been set up yet.
    if (!NgRedux.instance) {
        return undefined;
    }
    const options = getClassOptions(decoratedInstance);
    // This is not decorated with `@WithSubStore`. Return the root store.
    if (!options) {
        return NgRedux.instance;
    }
    // Dynamic base path support:
    const basePath = decoratedInstance[options.basePathMethodName]();
    if (hasBasePathChanged(decoratedInstance, basePath)) {
        clearInstanceState(decoratedInstance);
        setInstanceBasePath(decoratedInstance, basePath);
    }
    if (!basePath) {
        return NgRedux.instance;
    }
    const store = getInstanceStore(decoratedInstance);
    if (!store) {
        setInstanceStore(decoratedInstance, NgRedux.instance.configureSubStore(basePath, options.localReducer));
    }
    return getInstanceStore(decoratedInstance);
};
/**
 * Creates an Observable from the given selection parameters,
 * rooted at decoratedInstance's store, and caches it on the
 * instance for future use.
 * @hidden
 */
export const getInstanceSelection = (decoratedInstance, key, selector, transformer, comparator) => {
    const store = getBaseStore(decoratedInstance);
    if (store) {
        const selections = getInstanceSelectionMap(decoratedInstance);
        selections[key] =
            selections[key] ||
                (!transformer
                    ? store.select(selector, comparator)
                    : store.select(selector).pipe(obs$ => transformer(obs$, decoratedInstance), distinctUntilChanged(comparator)));
        return selections[key];
    }
    return undefined;
};
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bhbmd1bGFyLXJlZHV4L3N0b3JlLyIsInNvdXJjZXMiOlsiZGVjb3JhdG9ycy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQThCakQ7OztHQUdHO0FBQ0gsTUFBTSxXQUFXLEdBQUcsMENBQTBDLENBQUM7QUFFL0Q7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxxQkFBcUIsR0FBRywyQ0FBMkMsQ0FBQztBQUMxRSxNQUFNLHVCQUF1QixHQUMzQixnREFBZ0QsQ0FBQztBQUVuRDs7O0dBR0c7QUFDSCxNQUFNLHNCQUFzQixHQUFHLDhDQUE4QyxDQUFDO0FBRTlFLE1BQU0sZUFBZSxHQUFHLENBQUMsaUJBQXNCLEVBQXVCLEVBQUUsQ0FDdEUsaUJBQWlCLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUU3QyxjQUFjO0FBQ2QsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQzdCLHlCQUE4QixFQUM5QixPQUE0QixFQUN0QixFQUFFO0lBQ1IseUJBQXlCLENBQUMsV0FBVyxDQUFDLEdBQUcsT0FBTyxDQUFDO0FBQ25ELENBQUMsQ0FBQztBQUVGLHlEQUF5RDtBQUN6RCxrRUFBa0U7QUFDbEUsNEVBQTRFO0FBQzVFLDRCQUE0QjtBQUM1QixNQUFNLGdCQUFnQixHQUFHLENBQ3ZCLGlCQUFzQixFQUN0QixLQUE0QixFQUM1QixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDOztBQUV4RCxNQUFNLGdCQUFnQixHQUFHLENBQUMsaUJBQXNCLEVBQXdCLEVBQUUsQ0FDeEUsaUJBQWlCLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7QUFFM0MsTUFBTSx1QkFBdUIsR0FBRyxD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QyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUN6QixJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsaUJBQWlCLENBQUMsRUFDNUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLENBQ2pDLENBQUMsQ0FBQztRQUVULE9BQU8sVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3hCO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW55QWN0aW9uLCBSZWR1Y2VyIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOZ1JlZHV4IH0gZnJvbSAnLi4vY29tcG9uZW50cy9uZy1yZWR1eCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlU3RvcmUgfSBmcm9tICcuLi9jb21wb25lbnRzL29ic2VydmFibGUtc3RvcmUnO1xuaW1wb3J0IHtcbiAgQ29tcGFyYXRvcixcbiAgUGF0aFNlbGVjdG9yLFxuICBTZWxlY3RvcixcbiAgVHJhbnNmb3JtZXIsXG59IGZyb20gJy4uL2NvbXBvbmVudHMvc2VsZWN0b3JzJztcblxuLyoqXG4gKiBVc2VkIHdpdGggdGhlIGBAV2l0aFN1YlN0b3JlYCBjbGFzcyBkZWNvcmF0b3IgdG8gZGVmaW5lIGEgU3ViU3RvcmUgKEFLQSBhXG4gKiBmcmFjdGFsIHN0b3JlKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvIG9uIHN1YnN0b3Jlcywgc2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci1yZWR1eC9wbGF0Zm9ybS9ibG9iL21hc3Rlci9wYWNrYWdlcy9zdG9yZS9hcnRpY2xlcy9mcmFjdGFsLXN0b3JlLm1kXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRnJhY3RhbFN0b3JlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiBhbiBpbnN0YW5jZSBtZXRob2QgdGhhdCB3aWxsIGRlZmluZSB0aGVcbiAgICogYmFzZSBwYXRoIGZvciB0aGUgc3ViU3RvcmUuIFRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheVxuICAgKiBvZiBwcm9wZXJ0eSBuYW1lcyBvciB1bmRlZmluZWQvbnVsbC5cbiAgICovXG4gIGJhc2VQYXRoTWV0aG9kTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbG9jYWxSZWR1Y2VyIGZvciB0aGUgc3Vic3RvcmUgaW4gcXVlc3Rpb24uXG4gICAqL1xuICBsb2NhbFJlZHVjZXI6IFJlZHVjZXI8YW55LCBBbnlBY3Rpb24+O1xufVxuXG4vKipcbiAqIE9QVElPTlNfS0VZOiB0aGlzIGlzIHBlci1jbGFzcyAoc3RhdGljKSBhbmQgaG9sZHMgdGhlIGNvbmZpZyBmcm9tIHRoZVxuICogQFN1YlN0b3JlIGRlY29yYXRvci5cbiAqL1xuY29uc3QgT1BUSU9OU19LRVkgPSAnQGFuZ3VsYXItcmVkdXg6OnN1YnN0b3JlOjpjbGFzczo6b3B0aW9ucyc7XG5cbi8qKlxuICogSU5TVEFOQ0VfU1VCU1RPUkVfS0VZLCBJTlNUQU5DRV9TRUxFQ1RJT05TX0tFWTogdGhlc2UgYXJlIHBlci1pbnN0YW5jZVxuICogKG5vbi1zdGF0aWMpIGFuZCBob2xkcyByZWZlcmVuY2VzIHRvIHRoZSBzdWJzdG9yZXMvc2VsZWN0ZWQgb2JzZXJ2YWJsZXNcbiAqIHRvIGJlIHVzZWQgYnkgYW4gaW5zdGFuY2Ugb2YgYSBkZWNvcmF0ZWQgY2xhc3MuIEknbSBub3QgdXNpbmdcbiAqIHJlZmxlY3QtbWV0YWRhdGEgaGVyZSBiZWNhdXNlIEkgd2FudFxuICpcbiAqIDEuIGRpZmZlcmVudCBpbnN0YW5jZXMgdG8gaGF2ZSBkaWZmZXJlbnQgc3Vic3RvcmVzIGluIHRoZSBjYXNlIHdoZXJlXG4gKiBgYmFzZVBhdGhNZXRob2ROYW1lYCBpcyBkeW5hbWljLlxuICogMi4gdGhlIGluc3RhbmNlIHN1YnN0b3JlIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkIHdoZW4gdGhlIGluc3RhbmNlIGlzIG5vXG4gKiBsb25nZXIgcmVhY2hhYmxlLlxuICogVGhpcyBpcyB0aGVyZWZvcmUgYW4gb3duLXByb3BlcnR5IG9uIHRoZSBhY3R1YWwgaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZFxuICogY2xhc3MuXG4gKi9cbmNvbnN0IElOU1RBTkNFX1NVQlNUT1JFX0tFWSA9ICdAYW5ndWxhci1yZWR1eDo6c3Vic3RvcmU6Omluc3RhbmNlOjpzdG9yZSc7XG5jb25zdCBJTlNUQU5DRV9TRUxFQ1RJT05TX0tFWSA9XG4gICdAYW5ndWxhci1yZWR1eDo6c3Vic3RvcmU6Omluc3RhbmNlOjpzZWxlY3Rpb25zJztcblxuLyoqXG4gKiBVc2VkIHRvIGRldGVjdCB3aGVuIHRoZSBiYXNlIHBhdGggY2hhbmdlcyAtIHRoaXMgYWxsb3dzIGNvbXBvbmVudHMgdG9cbiAqIGR5bmFtaWNhbGx5IGFkanVzdCB0aGVpciBzZWxlY3Rpb25zIGlmIG5lY2Vzc2FyeS5cbiAqL1xuY29uc3QgSU5TVEFOQ0VfQkFTRV9QQVRIX0tFWSA9ICdAYW5ndWxhci1yZWR1eDo6c3Vic3RvcmU6Omluc3RhbmNlOjpiYXNlcGF0aCc7XG5cbmNvbnN0IGdldENsYXNzT3B0aW9ucyA9IChkZWNvcmF0ZWRJbnN0YW5jZTogYW55KTogRnJhY3RhbFN0b3JlT3B0aW9ucyA9PlxuICBkZWNvcmF0ZWRJbnN0YW5jZS5jb25zdHJ1Y3RvcltPUFRJT05TX0tFWV07XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgY29uc3Qgc2V0Q2xhc3NPcHRpb25zID0gKFxuICBkZWNvcmF0ZWRDbGFzc0NvbnN0cnVjdG9yOiBhbnksXG4gIG9wdGlvbnM6IEZyYWN0YWxTdG9yZU9wdGlvbnMsXG4pOiB2b2lkID0+IHtcbiAgZGVjb3JhdGVkQ2xhc3NDb25zdHJ1Y3RvcltPUFRJT05TX0tFWV0gPSBvcHRpb25zO1xufTtcblxuLy8gSSB3YW50IHRoZSBzdG9yZSB0byBiZSBzYXZlZCBvbiB0aGUgYWN0dWFsIGluc3RhbmNlIHNvXG4vLyAxLiBkaWZmZXJlbnQgaW5zdGFuY2VzIGNhbiBoYXZlIGRpc3RpbmN0IHN1YnN0b3JlcyBpZiBuZWNlc3Nhcnlcbi8vIDIuIHRoZSBzdWJzdG9yZS9zZWxlY3Rpb25zIHdpbGwgYmUgbWFya2VkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gd2hlbiB0aGVcbi8vICAgIGluc3RhbmNlIGlzIGRlc3Ryb3llZC5cbmNvbnN0IHNldEluc3RhbmNlU3RvcmUgPSAoXG4gIGRlY29yYXRlZEluc3RhbmNlOiBhbnksXG4gIHN0b3JlPzogT2JzZXJ2YWJsZVN0b3JlPGFueT4sXG4pID0+IChkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9TVUJTVE9SRV9LRVldID0gc3RvcmUpO1xuXG5jb25zdCBnZXRJbnN0YW5jZVN0b3JlID0gKGRlY29yYXRlZEluc3RhbmNlOiBhbnkpOiBPYnNlcnZhYmxlU3RvcmU8YW55PiA9PlxuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9TVUJTVE9SRV9LRVldO1xuXG5jb25zdCBnZXRJbnN0YW5jZVNlbGVjdGlvbk1hcCA9IChkZWNvcmF0ZWRJbnN0YW5jZTogYW55KSA9PiB7XG4gIGNvbnN0IG1hcCA9IGRlY29yYXRlZEluc3RhbmNlW0lOU1RBTkNFX1NFTEVDVElPTlNfS0VZXSB8fCB7fTtcbiAgZGVjb3JhdGVkSW5zdGFuY2VbSU5TVEFOQ0VfU0VMRUNUSU9OU19LRVldID0gbWFwO1xuICByZXR1cm4gbWFwO1xufTtcblxuY29uc3QgaGFzQmFzZVBhdGhDaGFuZ2VkID0gKFxuICBkZWNvcmF0ZWRJbnN0YW5jZTogYW55LFxuICBiYXNlUGF0aD86IFBhdGhTZWxlY3Rvcixcbik6IGJvb2xlYW4gPT5cbiAgZGVjb3JhdGVkSW5zdGFuY2VbSU5TVEFOQ0VfQkFTRV9QQVRIX0tFWV0gIT09IChiYXNlUGF0aCB8fCBbXSkudG9TdHJpbmcoKTtcblxuY29uc3Qgc2V0SW5zdGFuY2VCYXNlUGF0aCA9IChcbiAgZGVjb3JhdGVkSW5zdGFuY2U6IGFueSxcbiAgYmFzZVBhdGg/OiBQYXRoU2VsZWN0b3IsXG4pOiB2b2lkID0+IHtcbiAgZGVjb3JhdGVkSW5zdGFuY2VbSU5TVEFOQ0VfQkFTRV9QQVRIX0tFWV0gPSAoYmFzZVBhdGggfHwgW10pLnRvU3RyaW5nKCk7XG59O1xuXG5jb25zdCBjbGVhckluc3RhbmNlU3RhdGUgPSAoZGVjb3JhdGVkSW5zdGFuY2U6IGFueSkgPT4ge1xuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9TRUxFQ1RJT05TX0tFWV0gPSBudWxsO1xuICBkZWNvcmF0ZWRJbnN0YW5jZVtJTlNUQU5DRV9TVUJTVE9SRV9LRVldID0gbnVsbDtcbiAgZGVjb3JhdGVkSW5zdGFuY2VbSU5TVEFOQ0VfQkFTRV9QQVRIX0tFWV0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzdG9yZSBhc3NvY2lhdGVkIHdpdGggYSBkZWNvcmF0ZWQgaW5zdGFuY2UgKGUuZy4gYVxuICogY29tcG9uZW50IG9yIHNlcnZpY2UpXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCYXNlU3RvcmUgPSAoXG4gIGRlY29yYXRlZEluc3RhbmNlOiBhbnksXG4pOiBPYnNlcnZhYmxlU3RvcmU8YW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gIC8vIFRoZSByb290IHN0b3JlIGhhc24ndCBiZWVuIHNldCB1cCB5ZXQuXG4gIGlmICghTmdSZWR1eC5pbnN0YW5jZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gZ2V0Q2xhc3NPcHRpb25zKGRlY29yYXRlZEluc3RhbmNlKTtcblxuICAvLyBUaGlzIGlzIG5vdCBkZWNvcmF0ZWQgd2l0aCBgQFdpdGhTdWJTdG9yZWAuIFJldHVybiB0aGUgcm9vdCBzdG9yZS5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIE5nUmVkdXguaW5zdGFuY2U7XG4gIH1cblxuICAvLyBEeW5hbWljIGJhc2UgcGF0aCBzdXBwb3J0OlxuICBjb25zdCBiYXNlUGF0aCA9IGRlY29yYXRlZEluc3RhbmNlW29wdGlvbnMuYmFzZVBhdGhNZXRob2ROYW1lXSgpO1xuICBpZiAoaGFzQmFzZVBhdGhDaGFuZ2VkKGRlY29yYXRlZEluc3RhbmNlLCBiYXNlUGF0aCkpIHtcbiAgICBjbGVhckluc3RhbmNlU3RhdGUoZGVjb3JhdGVkSW5zdGFuY2UpO1xuICAgIHNldEluc3RhbmNlQmFzZVBhdGgoZGVjb3JhdGVkSW5zdGFuY2UsIGJhc2VQYXRoKTtcbiAgfVxuXG4gIGlmICghYmFzZVBhdGgpIHtcbiAgICByZXR1cm4gTmdSZWR1eC5pbnN0YW5jZTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlID0gZ2V0SW5zdGFuY2VTdG9yZShkZWNvcmF0ZWRJbnN0YW5jZSk7XG4gIGlmICghc3RvcmUpIHtcbiAgICBzZXRJbnN0YW5jZVN0b3JlKFxuICAgICAgZGVjb3JhdGVkSW5zdGFuY2UsXG4gICAgICBOZ1JlZHV4Lmluc3RhbmNlLmNvbmZpZ3VyZVN1YlN0b3JlKGJhc2VQYXRoLCBvcHRpb25zLmxvY2FsUmVkdWNlciksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBnZXRJbnN0YW5jZVN0b3JlKGRlY29yYXRlZEluc3RhbmNlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gdGhlIGdpdmVuIHNlbGVjdGlvbiBwYXJhbWV0ZXJzLFxuICogcm9vdGVkIGF0IGRlY29yYXRlZEluc3RhbmNlJ3Mgc3RvcmUsIGFuZCBjYWNoZXMgaXQgb24gdGhlXG4gKiBpbnN0YW5jZSBmb3IgZnV0dXJlIHVzZS5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlU2VsZWN0aW9uID0gPFQ+KFxuICBkZWNvcmF0ZWRJbnN0YW5jZTogYW55LFxuICBrZXk6IHN0cmluZyB8IHN5bWJvbCxcbiAgc2VsZWN0b3I6IFNlbGVjdG9yPGFueSwgVD4sXG4gIHRyYW5zZm9ybWVyPzogVHJhbnNmb3JtZXI8YW55LCBUPixcbiAgY29tcGFyYXRvcj86IENvbXBhcmF0b3IsXG4pID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRCYXNlU3RvcmUoZGVjb3JhdGVkSW5zdGFuY2UpO1xuXG4gIGlmIChzdG9yZSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSBnZXRJbnN0YW5jZVNlbGVjdGlvbk1hcChkZWNvcmF0ZWRJbnN0YW5jZSk7XG5cbiAgICBzZWxlY3Rpb25zW2tleV0gPVxuICAgICAgc2VsZWN0aW9uc1trZXldIHx8XG4gICAgICAoIXRyYW5zZm9ybWVyXG4gICAgICAgID8gc3RvcmUuc2VsZWN0KHNlbGVjdG9yLCBjb21wYXJhdG9yKVxuICAgICAgICA6IHN0b3JlLnNlbGVjdChzZWxlY3RvcikucGlwZShcbiAgICAgICAgICAgIG9icyQgPT4gdHJhbnNmb3JtZXIob2JzJCwgZGVjb3JhdGVkSW5zdGFuY2UpLFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyYXRvciksXG4gICAgICAgICAgKSk7XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4iXX0=